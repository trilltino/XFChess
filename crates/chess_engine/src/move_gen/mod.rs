//! Move generation with precalculated move tables
//!
//! This module generates all legal moves for a position using precalculated
//! move tables for efficiency. Tables are computed once at startup.
//!
//! ## Architecture
//!
//! The move generation system uses a two-phase approach:
//!
//! 1. **Precomputation** (`tables`): At game initialization, all possible
//!    pseudo-legal moves for each piece type from each square are computed
//!    and stored in lookup tables.
//!
//! 2. **Runtime Generation** (piece modules): During gameplay, moves are
//!    generated by filtering the precomputed tables based on:
//!    - Board occupancy (can't move through or capture own pieces)
//!    - Special rules (en passant, castling, promotion)
//!    - Check legality (can't leave king in check)
//!
//! ## Module Organization
//!
//! - **`tables`** - Precomputation of move tables for all piece types
//! - **`pawn`** - Pawn move generation (pushes, captures, double pushes)
//! - **`knight`** - Knight move generation (L-shaped jumps)
//! - **`bishop`** - Bishop move generation (diagonal sliding)
//! - **`rook`** - Rook move generation (horizontal/vertical sliding)
//! - **`queen`** - Queen move generation (combines bishop and rook)
//! - **`king`** - King move generation (one square in any direction)
//! - **`sliding`** - Common logic for sliding pieces (bishop, rook, queen)
//! - **`attack`** - Attack detection and check validation
//!
//! ## Performance Characteristics
//!
//! - **Initialization**: ~1-2ms to compute all move tables
//! - **Move generation**: ~10-50Î¼s per position (depends on position complexity)
//! - **Memory usage**: ~2MB for all move tables
//! - **Lookup time**: O(1) for table access, O(n) for filtering where n = moves per piece
//!
//! ## Move Types
//!
//! The engine generates **pseudo-legal** moves, which are moves that:
//! - Follow the piece's movement rules
//! - Don't capture own pieces
//! - May or may not leave the king in check
//!
//! True legal moves are determined by checking if the move leaves the king
//! in check, which is done during move validation in the search algorithm.

mod attack;
mod bishop;
mod king;
mod knight;
mod pawn;
mod queen;
mod rook;
mod sliding;
mod tables;

pub use attack::is_in_check;
pub use tables::init_move_tables;

use crate::board::*;
use crate::constants::*;
use crate::types::*;

/// Generate all pseudo-legal moves for a given color
///
/// This is the main entry point for move generation. It iterates through
/// all pieces of the specified color and generates moves for each piece
/// using the appropriate piece-specific generator.
///
/// # Arguments
///
/// * `game` - The current game state
/// * `color` - Color to generate moves for (1 for White, -1 for Black)
///
/// # Returns
///
/// Vector of `KK` moves representing all pseudo-legal moves for the color
///
/// # Performance
///
/// Typical performance:
/// - Opening position: ~20 moves per color
/// - Middlegame: ~30-40 moves per color
/// - Endgame: ~20-30 moves per color
///
/// # Examples
///
/// ```rust,ignore
/// let moves = generate_pseudo_legal_moves(&game, COLOR_WHITE);
/// println!("White has {} possible moves", moves.len());
/// ```
pub fn generate_pseudo_legal_moves(game: &Game, color: Color) -> Vec<KK> {
    let mut moves = Vec::with_capacity(200); // Pre-allocate for typical position

    // Iterate through all squares on the board
    for square in 0..64 {
        let piece = game.board[square];

        // Skip empty squares and opponent pieces
        if !piece_belongs_to(piece, color) {
            continue;
        }

        let piece_type = piece.abs();

        // Generate moves based on piece type
        match piece_type {
            PAWN_ID => pawn::generate_pawn_moves(game, square as i8, color, &mut moves),
            KNIGHT_ID => knight::generate_knight_moves(game, square as i8, color, &mut moves),
            BISHOP_ID => bishop::generate_bishop_moves(game, square as i8, color, &mut moves),
            ROOK_ID => rook::generate_rook_moves(game, square as i8, color, &mut moves),
            QUEEN_ID => queen::generate_queen_moves(game, square as i8, color, &mut moves),
            KING_ID => king::generate_king_moves(game, square as i8, color, &mut moves),
            _ => {} // Empty square or invalid piece
        }
    }

    moves
}
