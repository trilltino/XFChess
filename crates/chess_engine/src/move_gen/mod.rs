//! Move generation with precalculated move tables
//!
//! This module generates all legal moves for a position using precalculated
//! move tables for efficiency. Tables are computed once at startup.
//!
//! ## Architecture
//!
//! The move generation system uses a two-phase approach:
//!
//! 1. **Precomputation** (`tables`): At game initialization, all possible
//!    pseudo-legal moves for each piece type from each square are computed
//!    and stored in lookup tables.
//!
//! 2. **Runtime Generation** (piece modules): During gameplay, moves are
//!    generated by filtering the precomputed tables based on:
//!    - Board occupancy (can't move through or capture own pieces)
//!    - Special rules (en passant, castling, promotion)
//!    - Check legality (can't leave king in check)
//!
//! ## Module Organization
//!
//! - **`tables`** - Precomputation of move tables for all piece types
//! - **`pawn`** - Pawn move generation (pushes, captures, double pushes)
//! - **`knight`** - Knight move generation (L-shaped jumps)
//! - **`bishop`** - Bishop move generation (diagonal sliding)
//! - **`rook`** - Rook move generation (horizontal/vertical sliding)
//! - **`queen`** - Queen move generation (combines bishop and rook)
//! - **`king`** - King move generation (one square in any direction)
//! - **`sliding`** - Common logic for sliding pieces (bishop, rook, queen)
//! - **`attack`** - Attack detection and check validation
//!
//! ## Performance Characteristics
//!
//! - **Initialization**: ~1-2ms to compute all move tables
//! - **Move generation**: ~10-50Î¼s per position (depends on position complexity)
//! - **Memory usage**: ~2MB for all move tables
//! - **Lookup time**: O(1) for table access, O(n) for filtering where n = moves per piece
//!
//! ## Move Types
//!
//! The engine generates **pseudo-legal** moves, which are moves that:
//! - Follow the piece's movement rules
//! - Don't capture own pieces
//! - May or may not leave the king in check
//!
//! True legal moves are determined by checking if the move leaves the king
//! in check, which is done during move validation in the search algorithm.

mod attack;
mod bishop;
mod king;
mod knight;
mod pawn;
mod queen;
mod rook;
mod sliding;
mod tables;

pub use attack::is_in_check;
pub use tables::init_move_tables;

use crate::board::*;
use crate::constants::*;
use crate::types::*;

/// Generate all pseudo-legal moves for a given color
///
/// This is the main entry point for move generation. It iterates through
/// all pieces of the specified color and generates moves for each piece
/// using the appropriate piece-specific generator.
///
/// # Arguments
///
/// * `game` - The current game state
/// * `color` - Color to generate moves for (1 for White, -1 for Black)
///
/// # Returns
///
/// Vector of `KK` moves representing all pseudo-legal moves for the color
///
/// # Performance
///
/// Typical performance:
/// - Opening position: ~20 moves per color
/// - Middlegame: ~30-40 moves per color
/// - Endgame: ~20-30 moves per color
///
/// # Examples
///
/// ```rust,ignore
/// let moves = generate_pseudo_legal_moves(&game, COLOR_WHITE);
/// println!("White has {} possible moves", moves.len());
/// ```
pub fn generate_pseudo_legal_moves(game: &Game, color: Color) -> Vec<KK> {
    let mut moves = Vec::with_capacity(200); // Pre-allocate for typical position

    // Iterate through all squares on the board
    for square in 0..64 {
        let piece = game.board[square];

        // Skip empty squares and opponent pieces
        if !piece_belongs_to(piece, color) {
            continue;
        }

        let piece_type = piece.abs();

        // Generate moves based on piece type
        match piece_type {
            PAWN_ID => pawn::generate_pawn_moves(game, square as i8, color, &mut moves),
            KNIGHT_ID => knight::generate_knight_moves(game, square as i8, color, &mut moves),
            BISHOP_ID => bishop::generate_bishop_moves(game, square as i8, color, &mut moves),
            ROOK_ID => rook::generate_rook_moves(game, square as i8, color, &mut moves),
            QUEEN_ID => queen::generate_queen_moves(game, square as i8, color, &mut moves),
            KING_ID => king::generate_king_moves(game, square as i8, color, &mut moves),
            _ => {} // Empty square or invalid piece
        }
    }

    moves
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::api::new_game;

    #[test]
    fn test_generate_moves_starting_position() {
        let game = new_game();

        // White should have 20 moves from starting position
        // 16 pawn moves (8 pawns x 2 each) + 4 knight moves (2 knights x 2 each)
        let white_moves = generate_pseudo_legal_moves(&game, COLOR_WHITE);
        assert_eq!(
            white_moves.len(),
            20,
            "White should have 20 moves in starting position"
        );

        // Black should also have 20 moves
        let black_moves = generate_pseudo_legal_moves(&game, COLOR_BLACK);
        assert_eq!(
            black_moves.len(),
            20,
            "Black should have 20 moves in starting position"
        );
    }

    #[test]
    fn test_generate_moves_includes_pawns() {
        let game = new_game();
        let moves = generate_pseudo_legal_moves(&game, COLOR_WHITE);

        // Check that pawn moves are included (e2-e3, e2-e4, etc.)
        // Pawn on e2 (position 12) should be able to move to e3 (20) and e4 (28)
        let e2_moves: Vec<_> = moves.iter().filter(|m| m.src == 12).collect();
        assert!(
            e2_moves.len() >= 2,
            "Pawn on e2 should have at least 2 moves"
        );
    }

    #[test]
    fn test_generate_moves_includes_knights() {
        let game = new_game();
        let moves = generate_pseudo_legal_moves(&game, COLOR_WHITE);

        // Knight on b1 (position 1) should be able to move to a3 and c3
        let b1_moves: Vec<_> = moves.iter().filter(|m| m.src == 1).collect();
        assert_eq!(b1_moves.len(), 2, "Knight on b1 should have 2 moves");
    }

    #[test]
    fn test_move_count_changes_after_move() {
        let mut game = new_game();

        // After e2-e4, White should have different move count
        let initial_moves = generate_pseudo_legal_moves(&game, COLOR_WHITE).len();

        // Manually move pawn e2 to e4
        game.board[12] = 0; // Clear e2
        game.board[28] = W_PAWN; // Place pawn on e4

        let after_moves = generate_pseudo_legal_moves(&game, COLOR_WHITE).len();

        // Move count should change (opens up for queen and bishop)
        assert_ne!(
            initial_moves, after_moves,
            "Move count should change after pawn move"
        );
    }

    #[test]
    fn test_no_moves_for_empty_board() {
        let mut game = new_game();
        // Clear the board
        for i in 0..64 {
            game.board[i] = 0;
        }

        let moves = generate_pseudo_legal_moves(&game, COLOR_WHITE);
        assert_eq!(moves.len(), 0, "Empty board should have no moves");
    }

    #[test]
    fn test_king_moves_in_isolation() {
        let mut game = new_game();
        // Clear the board except for white king
        for i in 0..64 {
            game.board[i] = 0;
        }
        game.board[28] = W_KING; // King on e4

        let moves = generate_pseudo_legal_moves(&game, COLOR_WHITE);
        // King in center should have 8 moves
        assert_eq!(moves.len(), 8, "Lone king in center should have 8 moves");
    }
}
